import time
import json
import mysql.connector
from zapv2 import ZAPv2
from reportlab.lib import colors
from reportlab.lib.pagesizes import A4
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph
from reportlab.lib.styles import getSampleStyleSheet
from reportlab.lib.units import inch
from dotenv import load_dotenv
import os

load_dotenv()  # Load environment variables from .env file

# Get user input for API key and target URL
API_KEY = input("Enter your OWASP ZAP API key: ")
TARGET_URL = input("Enter the target URL to scan (e.g., http://example.com): ")
ZAP_PROXY = 'http://127.0.0.1:8080'

# Initialize ZAP instance
zap = ZAPv2(apikey=API_KEY, proxies={'http': ZAP_PROXY, 'https': ZAP_PROXY})

# Connect to MySQL database
db_connection = mysql.connector.connect(
    host=os.getenv('DB_HOST'),          # MySQL server address
    user= os.getenv('DB_USER'),      # Your MySQL username
    password=os.getenv('DB_PASSWORD'),   # Your MySQL password
    database=os.getenv('DB_NAME')  # Database name
)
cursor = db_connection.cursor()

def run_automated_scan():
    print(f"Accessing target URL: {TARGET_URL}")
    zap.urlopen(TARGET_URL)
    time.sleep(2)

    print(f"Starting active scan on: {TARGET_URL}")
    scan_id = zap.ascan.scan(TARGET_URL)

    while int(zap.ascan.status(scan_id)) < 100:
        print(f"Scan progress: {zap.ascan.status(scan_id)}%")
        time.sleep(5)

    print("Active scan complete.")
    alerts = zap.core.alerts(baseurl=TARGET_URL)

    # Insert scan results into the database
    insert_vulnerabilities(alerts)

    # Ask the user if they want to generate a report
    generate_report_option = input("Would you like to generate a report? (yes/no): ").strip().lower()
    if generate_report_option in ['yes', 'y']:
        report = generate_report(alerts)
        save_report(report)

        # Ask if the user wants a PDF report
        pdf_report_option = input("Would you like to export the report as a PDF? (yes/no): ").strip().lower()
        if pdf_report_option in ['yes', 'y']:
            generate_pdf_report(report)
    else:
        print("Report generation skipped.")

def insert_vulnerabilities(alerts):
    """Insert scan results into the MySQL database."""
    for alert in alerts:
        cursor.execute('''  
            INSERT INTO vulnerabilities (url, vulnerability_type, severity, date_detected)
            VALUES (%s, %s, %s, %s)
        ''', (
            alert['url'],
            alert['name'],
            alert['risk'],
            time.strftime('%Y-%m-%d %H:%M:%S')  # Current date and time
        ))
    db_connection.commit()
    print("Vulnerabilities have been recorded in the database.")

def generate_report(alerts):
    report = {
        "target_url": TARGET_URL,
        "vulnerabilities": []
    }

    if alerts:
        for alert in alerts:
            vulnerability = {
                "name": alert['name'],
                "risk": alert['risk'],
                "url": alert['url'],
                "description": alert.get('description', 'No description provided.'),
                "solution": alert.get('solution', 'No solution provided.')
            }
            report["vulnerabilities"].append(vulnerability)
    else:
        report["vulnerabilities"].append({"message": "No vulnerabilities found."})

    return report

def save_report(report):
    report_filename = f"zap_scan_report_{TARGET_URL.replace('http://', '').replace('https://', '').replace('/', '_')}.json"
    
    with open(report_filename, 'w') as report_file:
        json.dump(report, report_file, indent=4)
    
    print(f"Report saved as: {report_filename}")

def generate_pdf_report(report):
    pdf_report_filename = f"zap_scan_report_{report['target_url'].replace('http://', '').replace('https://', '').replace('/', '_')}.pdf"
    
    # Create a SimpleDocTemplate
    pdf = SimpleDocTemplate(pdf_report_filename, pagesize=A4)
    
    # Create a list to hold elements
    elements = []
    
    # Add a title
    styles = getSampleStyleSheet()
    title = Paragraph(f"Vulnerability Report for {report['target_url']}", styles['Title'])
    elements.append(title)
    
    # Create a table with vulnerability data
    data = [['Vulnerability', 'Risk Level', 'URL', 'Description', 'Solution']]
    
    for vulnerability in report['vulnerabilities']:
        row = [
            vulnerability['name'],
            vulnerability['risk'],
            vulnerability['url'],
            vulnerability.get('description', 'No description provided.'),
            vulnerability.get('solution', 'No solution provided.'),
        ]
        data.append(row)
    
    # Create a table
    table = Table(data)
    
    # Add style to the table
    style = TableStyle([
        ('BACKGROUND', (0, 0), (-1, 0), colors.grey),  # Header row
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
        ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
        ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
        ('GRID', (0, 0), (-1, -1), 1, colors.black),
    ])
    
    table.setStyle(style)
    
    # Append the table to the elements
    elements.append(table)
    
    # Build the PDF
    pdf.build(elements)

# Example usage
report_data = {
    'target_url': 'http://example.com',
    'vulnerabilities': [
        {'name': 'SQL Injection', 'risk': 'High', 'url': 'http://example.com/vuln1', 
         'description': 'Potential SQL injection vulnerability.', 'solution': 'Sanitize inputs.'},
        {'name': 'XSS', 'risk': 'Medium', 'url': 'http://example.com/vuln2', 
         'description': 'Cross-site scripting vulnerability.', 'solution': 'Use escaping.'}
    ]
}

generate_pdf_report(report_data)


# Directly run the automated scan for testing
if __name__ == "__main__":
    run_automated_scan()

# Close the database connection at the end
cursor.close()
db_connection.close()
